from threading import Thread
from subprocess import Popen, PIPE
#import chardet
import os
import platform

#os.device_encoding(0) get the correct encoding instead of the chardet geuss
encoding = os.device_encoding(0)
#encoding=None if python not connected to terminal
if encoding == None:
	print("Your OS is %s" % platform.system())
	if platform.system() == 'Windows':
		encoding = 'cp437'		

#the threading is to support time out
class Command(object):
	def __init__(self, cmd, path, silence=False):
		self.cmd = cmd
		self.process = None
		self.path = path
		self.silence = silence
		self.output = 'not executed'

	def readyPOPENOutput(self, tople):
		if tople:
			if type(tople) is tuple:
				(output,_) = tople
				if(type(output)==type(b'0')):
					#print(chardet.detect(output))
					if encoding == None:
						output=output.decode()
					else:
						output=output.decode(encoding)
				output = output.strip()
				return output.split('\n')
			else:
				return tople.split('\n')
		else:
			print('no output')
			exit(-2)
	
	#timeout is in seconds
	def run(self, timeout):
		self.output = 'not finished'
		def target():
			#print('Thread started', end="\r")	#print('\nThread started\n',getcwd())
			if not self.silence:
				print(self.cmd)
			self.process = Popen(self.cmd, cwd=self.path, stdout=PIPE)			
			self.output = self.process.communicate()
			#print('Thread finished', end="\r")

		thread = Thread(target=target)
		thread.start()

		thread.join(timeout)
		if thread.is_alive():
			if not self.silence:
				print('Terminating process, command did not finish in time', end="\r")
			self.process.terminate()
			thread.join()
		#print('process.returncode', self.process.returncode)
		return self.readyPOPENOutput(self.output)

#use
#psh = ["powershell.exe", args...]
#command = Command(cmd, path)
#command.run(timeout=time_sec)
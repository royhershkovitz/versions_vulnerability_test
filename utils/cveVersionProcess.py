#>>> 'ba' > 'aa'
#True
#>>> 'ba' > 'bb'
#False
#>>> '11' > '2'
#False        
#compare 0.6.45-1ubuntu1 vs 0.6.55
#0.6.4 vs 0.6.15
from packaging.version import LegacyVersion
def LEVersions(version1, version2):#ver and earlier
    return LegacyVersion(version1) <= LegacyVersion(version2)
    
def LVersions(version1, version2):#isBefore
    return LegacyVersion(version1) < LegacyVersion(version2)

def BEVersions(version1, version2):#bigEqual
    return LegacyVersion(version1) >= LegacyVersion(version2)
    
def EVersions(version1, version2):
    return LegacyVersion(version1) == LegacyVersion(version2)

def isVersion(ver):
    return len(ver.split('.')) > 1

def validateNameGetVersionSplit(verArr, name):
    #split name
    #google:chrome:73.0.3683.103
    nameArr = name.split(' ')
    if len(nameArr) <= 1:
        nameArr = name.split('.')#microsoft store naming
    if len(nameArr) <= 1:#no splitting for you
        return -1
    
    i = j = 0
    while i < len(verArr) and verArr[i]!=nameArr[j]:#search for our full name
        i += 1
    while i < len(verArr) and j < len(nameArr) and verArr[i]==nameArr[j]:#for name appears twice
        i += 1
        j += 1
    
    # next sould be version! and we finish name array
    # cpe:2.3:a:microsoft:sql_server_management_studio:17.9:*:*:*:*:*:*:*
    if i + 1 > len(verArr) or j < len(nameArr):
        return validateNameExist(verArr, '_'.join(nameArr))
    return i - 1#the last name index

#return what the name index
def validateNameExist(verArr, name):
    i = 0
    #double name
    while i < len(verArr) and verArr[i]!=name:#search for our full name
        i += 1
    if i + 1 < len(verArr) and verArr[i+1]==name:#for name appears twice
        i += 1

    if i + 1 > len(verArr):#next should be version!
        return -1
    return i

def validateNameGetVersion(verArr, name):
    # no android in version||smartphone applications are total different case in implementation and getting the packages
    # moreover the big OSes Android and Ios has an official package (application) manager that is widely used.
    for a in verArr:
        if a == 'android':
            return -1
    
    i = validateNameExist(verArr, name)
    
    if i == -1:
        return validateNameGetVersionSplit(verArr, name)    
    return i

def hasVersion(verText, name, cur_vr):
    name = name.lower()
    verText = verText.lower()
    verArr = verText.split(':')
    #does the name in the vulnerable products?
    i = validateNameGetVersion(verArr, name)
    if i == -1:
        return False
    
    if not cur_vr: #if we don't know the version we better return true
        return True
    
    if isVersion(verArr[i+1]):
        return LEVersions(cur_vr, verArr[i+1])
    #else:
    #    return verArr[i+1]=='*'#not stable enough since some have versions in the description
    return False

#validate that at least one version text place has my full name
#circl api affected versions
def verTextHasName(versions, name):    
    name = name.lower()
    if not versions:
        return True#no version mean no way to validate but summary
    for verText in versions:
        verText = verText.lower()
        verArr = verText.split(':')
        #does the name in the vulnerable products?
        i = validateNameGetVersion(verArr, name)
        if i != -1:
            return True
    return False

#getting from up to down (increase version num) make it easier to match the right verTex
def hasVersions(summary, versions, name, cur_vr):
    # man deb-version
    # [epoch:]upstream_version[-debian_revision]
    # : is the current epoch, used for downgrading 2:1.31.2
    # remove epoch for comparison
    # we do not need it and it is actually not comparing well with it (since one have it and the other don't)
    i = cur_vr.find(':')
    if i != -1:
        cur_vr = cur_vr[i+1:]
    for verText in versions:
        if hasVersion(verText, name, cur_vr):
            return verText
    if verTextHasName(versions, name):
        return summaryHasText(summary, name, cur_vr)
    return None

#Search just for affected version in cve description and return validating Text
#Cases
#Flask-Admin 1.5.2 != Flask
#before 1.15.2 and 2.0.1
#through 7.70
#5.12.2 through 5.14.2
#Google Chrome prior to 84.0.4147.89
#Adobe Flash Player for Google Chrome 32.0.0.371 and earlier,
#Adobe Flash Player for Microsoft Edge and Internet Explorer 32.0.0.330 and earlier
#Google Chrome on iOS prior to 80.0.3987.87
#WebView in Google Chrome on Android prior to 83.0.4103.106
#before version 1.7
#flask version Before 0.12.3
#Jenkins Git Plugin 4.2.0 and earlier != Git through 4.2.0
#The mincore() implementation in mm/mincore.c in the Linux kernel through 4.19.13
#Microsoft PowerPoint for Mac 2011
#TensorFlow 1.7.x and earlier - version start with the number before x
#Rare _ Amphora Images in OpenStack Octavia >=0.10.0 <2.1.2, >=3.0.0 <3.2.0, >=4.0.0 <4.1.0
#Citrix SD-WAN 10.2.x before 10.2.6 and 11.0.x before 11.0.3
#Multiple memory corruption issues were addressed with improved memory handling. This issue affected versions prior to iOS 12.1, tvOS 12.1, watchOS 5.1, Safari 12.0.1, iTunes 12.9.1, iCloud for Windows 7.8.
#(applications bundled in OS) Problem Apple have multiple os, and fix them independently for each cve without clear versioning for all of them
#This issue is fixed in iOS 13.5 and iPadOS 13.5, tvOS 13.4.5, watchOS 6.2.5, Safari 13.1.1, iTunes 12.10.7 for Windows, iCloud for Windows 11.2, iCloud for Windows 7.19.
#A memory corruption issue was addressed with improved memory handling. This issue is fixed in iOS 13.4 and iPadOS 13.4, tvOS 13.4, watchOS 6.2, Safari 13.1, iTunes for Windows 12.10.5, iCloud for Windows 10.9.3, iCloud for Windows 7.18. Processing maliciously crafted web content may lead to arbitrary code execution.

# Idea split by ". ". for each search for the app name.
# if != -1, search after i Search for version and the text.
# deny sentace with - 'fixed in'
# if version is like 1.2.x do v=v[0:-2] + [str(int(v[-2])+1)] v = '.'.join(v)
# compare versions
# Deny names that have from begin to version that have ['android', 'ios', 'plugin']
ver_words = ['prior', 'before']
specificCVE = ['android', 'ios', 'plugin']
#special case through, and earlier
def summaryHasText(summary, name, cur_vr):
    name = name.lower()
    cur_vr = cur_vr.lower()
    summary = summary.split('. ')
    
    for sentence in summary:
        sentence = sentence.lower()
        name_index = sentence.find(name)
        afterword = name_index+len(name)

        #print(sentence, afterword, len(sentence))
        if name_index == -1 or afterword >= len(sentence) or sentence[afterword]!=' ':#name not fully exist <Flask-Admin != Flask>
            continue
        if 'fixed in' in sentence:#sentence about fixed version. common at apple's CVE
            continue        
        if f'for {name}' in sentence:#cve of dependency of project
            continue

        badName = False
        seprate = sentence.rfind(',', 0, name_index)
        if seprate == -1:
            seprate = 0
        tmpSentence = sentence[seprate:name_index]
        for word in specificCVE:#this words means that this CVE is not for us
            if word in tmpSentence:
                badName = True
                break
        if badName:
            continue
        
        version_domain = getVersionDomainFromSentence(sentence[afterword:], cur_vr)
        if version_domain:
            return version_domain
    return None

def getVersionDomainFromSentence(sentence, cur_vr):
    sentence = sentence.strip()
    sentence = sentence.split(' ')
    sentence = [word for word in sentence if word != 'version']
    for i in range(0, min(len(sentence),3)):#len(sentence)):#version too far from name is not related... I hope
        if isVersion(sentence[i]):
            version_in_text = sentence[i].strip()
            if(version_in_text.endswith(',') or version_in_text.endswith('.') or version_in_text.endswith('-') or version_in_text.endswith(':')):
                version_in_text = version_in_text[:-1]#fix version from text
            
            version_in_text_x_low = None
            if version_in_text.endswith('.x'):#make 1.2.3.x -> 1.2.4
                try:
                    v = version_in_text.split('.')
                    v2=v[0:-2] + [str(int(v[-2])+1)]
                    version_in_text = '.'.join(v2)
                    version_in_text_x_low  = '.'.join(v[:-1])
                except:
                    print('fail parse ver.x',version_in_text,sentence)

            if  i > 1 and sentence[i-1]=='through' and isVersion(sentence[i-2]):
                version_in_text_low = sentence[i-2].strip()
                if LEVersions(cur_vr, version_in_text) and BEVersions(cur_vr, version_in_text_low):
                    return f'{sentence[i-2]} through {sentence[i]}'
            
            if sentence[i-1]=='through':
                if LEVersions(cur_vr, version_in_text):
                    return f'through {sentence[i]}'
            
            if i+2 < len(sentence)  and sentence[i+1]=='and' and sentence[i+2]=='earlier':
                if LEVersions(cur_vr, version_in_text):
                    return f'{sentence[i]} and earlier'

            if i > 1  and sentence[i-2]=='prior' and sentence[i-1]=='to':
                if LVersions(cur_vr, version_in_text):
                    return f'prior to {sentence[i]}'

            for bef_word in ver_words:
                if bef_word == sentence[i-1] and LVersions(cur_vr, version_in_text):
                    return f'{sentence[i-1]} {sentence[i]}'

            if version_in_text_x_low != None:
                if LEVersions(cur_vr, version_in_text) and BEVersions(cur_vr, version_in_text_x_low):
                    f'{sentence[i]}'
            elif EVersions(cur_vr, version_in_text):
                return version_in_text
    return None
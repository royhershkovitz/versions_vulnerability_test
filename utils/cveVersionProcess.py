#>>> 'ba' > 'aa'
#True
#>>> 'ba' > 'bb'
#False
#>>> '11' > '2'
#False        
#compare 0.6.45-1ubuntu1 vs 0.6.55
#0.6.4 vs 0.6.15
from packaging.version import LegacyVersion
def compareVersions(version1, version2):
    return LegacyVersion(version1) <= LegacyVersion(version2)

def bigThanVersions(version1, version2):
    return LegacyVersion(version1) > LegacyVersion(version2)
    
def equalVersions(version1, version2):
    return LegacyVersion(version1) == LegacyVersion(version2)

def isVersion(ver):
    return len(ver.split('.')) > 1

def validateNameGetVersionSplit(verArr, name):
    #split name
    #google:chrome:73.0.3683.103
    nameArr = name.split(' ')
    if len(nameArr) <= 1:
        nameArr = name.split('.')#microsoft store naming
    if len(nameArr) <= 1:#no splitting for you
        return -1
    
    i = j = 0
    while i < len(verArr) and verArr[i]!=nameArr[j]:#search for our full name
        i += 1
    while i < len(verArr) and j < len(nameArr) and verArr[i]==nameArr[j]:#for name appears twice
        i += 1
        j += 1
    
    # next sould be version! and we finish name array
    # cpe:2.3:a:microsoft:sql_server_management_studio:17.9:*:*:*:*:*:*:*
    if i + 1 > len(verArr) or j < len(nameArr):
        return validateNameExist(verArr, '_'.join(nameArr))
    return i - 1#the last name index

#return what the name index
def validateNameExist(verArr, name):
    i = 0
    #double name
    while i < len(verArr) and verArr[i]!=name:#search for our full name
        i += 1
    if i + 1 < len(verArr) and verArr[i+1]==name:#for name appears twice
        i += 1

    if i + 1 > len(verArr):#next sould be version!
        return -1
    return i

def validateNameGetVersion(verArr, name):
    # no android in version||smartphone applications are total different case in implementation and getting the packages
    # moreover the big OSes Android and Ios has an official package (application) manager that is widely used.
    for a in verArr:
        if a == 'android':
            return -1
    
    i = validateNameExist(verArr, name)
    
    if i == -1:
        return validateNameGetVersionSplit(verArr, name)    
    return i

def hasVersion(verText, name, cur_vr):
    name = name.lower()
    verText = verText.lower()
    verArr = verText.split(':')
    #does the name in the vulnerable products?
    i = validateNameGetVersion(verArr, name)
    if i == -1:
        return False
    
    if not cur_vr: #if we don't know the version we better return true
        return True
    
    if isVersion(verArr[i+1]):
        return compareVersions(cur_vr, verArr[i+1])
    #else:
    #    return verArr[i+1]=='*'#not stable enough since some have versions in the description
    return False

#validate that at least one version text place has my full name
def verTextHasName(versions, name):    
    name = name.lower()
    if not versions:
        return True#no version mean no way to validate but summary
    for verText in versions:
        verText = verText.lower()
        verArr = verText.split(':')
        #does the name in the vulnerable products?
        i = validateNameGetVersion(verArr, name)
        if i != -1:
            return True
    return False

#getting from up to down (increase version num) make it easier to match the right verTex
def hasVersions(summary, versions, name, cur_vr):
    # man deb-version
    # [epoch:]upstream_version[-debian_revision]
    # : is the current epoch, used for downgrading 2:1.31.2
    # remove epoch for comparison
    # we do not need it and it is actually not comparing well with it (since one have it and the other don't)
    i = cur_vr.find(':')
    if i != -1:
        cur_vr = cur_vr[i+1:]
    for verText in versions:
        if hasVersion(verText, name, cur_vr):
            return verText
    if verTextHasName(versions, name):
        return hasText(summary, name, cur_vr)
    return None

#Search just for affected version in cve description and return validating Text
#Cases
#Flask-Admin 1.5.2
#before 1.15.2 and 2.0.1
#through 7.70
#5.12.2 through 5.14.2
#Google Chrome prior to 84.0.4147.89
#Adobe Flash Player for Google Chrome 32.0.0.371 and earlier,
#Adobe Flash Player for Microsoft Edge and Internet Explorer 32.0.0.330 and earlier
#Google Chrome on iOS prior to 80.0.3987.87
#WebView in Google Chrome on Android prior to 83.0.4103.106
#before version 1.7
#flask version Before 0.12.3
#Jenkins Git Plugin 4.2.0 and earlier != Git through 4.2.0
#The mincore() implementation in mm/mincore.c in the Linux kernel through 4.19.13
#Microsoft PowerPoint for Mac 2011
#TensorFlow 1.7.x and earlier - version start with the number before x
#Rare _ Amphora Images in OpenStack Octavia >=0.10.0 <2.1.2, >=3.0.0 <3.2.0, >=4.0.0 <4.1.0
#Citrix SD-WAN 10.2.x before 10.2.6 and 11.0.x before 11.0.3
# This issue is fixed in iOS 13.5 and iPadOS 13.5, tvOS 13.4.5, watchOS 6.2.5, Safari 13.1.1, iTunes 12.10.7 for Windows, iCloud for Windows 11.2, iCloud for Windows 7.19.
ver_words = ['prior', 'before', 'through']
def hasText(summary, name, cur_vr):
    if not name in summary:
        return None
    summary = summary.split(' ')
    for i in range(1, len(summary)):
        if isVersion(summary[i]):
            version_in_text = summary[i].strip()
            if(version_in_text.endswith(',') or version_in_text.endswith('.') or version_in_text.endswith('-') or version_in_text.endswith(':')):
                version_in_text = version_in_text[:-1]#fix version from text

            if summary[i-1]=='through' and i > 1 and isVersion(summary[i-2]):
                version_in_textlow = summary[i-2].strip()
                if compareVersions(cur_vr, version_in_text) and bigThanVersions(cur_vr, version_in_textlow):
                    return f'{summary[i-2]} {summary[i-1]} {summary[i]}'

            for bef_word in ver_words:
                if bef_word == summary[i-1] and compareVersions(cur_vr, version_in_text):
                    return f'{summary[i-1]} {summary[i]}'
            if equalVersions(cur_vr, version_in_text):
                return version_in_text
    return None
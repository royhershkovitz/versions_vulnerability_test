from utils.HTTP_TOOL import get, post
import lxml.html as lh
import json
from multiprocessing import Pool
import time

url_serach_name = 'https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=%s'
url_serach_cve = 'https://cve.circl.lu/api/cve/%s'
table = 'table'
thead = 'thead'
open_xml = '<'
close_xml = '>'
def get_just_table(text, fields):
    start = 0
    end = len(text)
    while start < end:
        i = text.find(table,start,end)
        tmp_end = text.find(table, i+len(table), end)
        tmp_end = text.find(close_xml, tmp_end, end)
        tmp_start = text.rfind(open_xml,start,i)  
        all = True
        for field in fields:
            if all and text.find(field,tmp_start,tmp_end) == -1:
                all = False
        if all:
            return text[tmp_start:tmp_end+1]
        start = tmp_end
    return ''

def exploreHTML(text):
    doc  = lh.fromstring(text)
    tr_elements = doc.xpath('//tr')
    #print(tr_elements)
    j = 0
    for t in tr_elements:
        i=0
        for t2 in t:
            name=t2.text_content()
            print('%d %d:"%s"'%(j,i,name))
            i+=1
        j+=1

def harvestHTMLtable(text, fields):
    text = get_just_table(text, fields)
    #print(text)
    #exploreHTML(text)
    doc  = lh.fromstring(text)
    tr_elements = doc.xpath('//tr')
    out = []
    for i in range(1, len(tr_elements)):
        x = {}
        j = 0
        for field in fields:
            x[field] = tr_elements[i][j].text_content().strip()
            j += 1
        out.append(x)
    return out

cve_fields = ['Published', 'access', 'impact', 'assigner', 'id', 'vulnerable_product', 'summary']
cve_fields_print = [ 'id', 'summary', 'assigner', 'Published', 'access', 'impact']
#"access": { "authentication": "NONE",  "complexity": "LOW", "vector": "NETWORK" }
#"impact": { "availability": "PARTIAL", "confidentiality": "NONE", "integrity": "NONE" }
def get_cve(cve_name):
    text = get(url_serach_cve % cve_name)
    while text.find('<title>429 Too Many Requests</title') != -1:
        #print(f'--timeout-- ', end='\r')
        time.sleep(1.5)
        text = get(url_serach_cve % cve_name)
    try:
        c = json.loads(text)
    except:
        x = min(100,len(text))
        print('decode problem', text[:x])
        return None    
    return c

#TODO make sure it works
def hasVersion(verText, name, vr):
    name = name.lower()
    verArr = verText.split(':')
    i = 0
    while i < len(verArr) and verArr[i].lower()!=name:#search for our full name
        i += 1
    if i + 1 < len(verArr) and verArr[i+1].lower()==name:#for name appears twice
        i += 1
    if i + 1 > len(verArr):#next sould be version!
        return False
    
    if not vr: #if we don't know the version we better return true
        return True
    
    noDots = verArr[i+1].split('.')
    noDots2 = vr.split('.')
    #print(noDots, noDots2)
    i = 0
    while i < len(noDots) and i < len(noDots2):
        if noDots[i] != noDots2[i]:
            return False
        i+=1

    return True

def hasVersions(versions, name, vr):
    for verText in versions:
        if hasVersion(verText, name, vr):
            return True
    return False

#get cves and verify version
def look_entry(entry):
    entry_cves = harvestHTMLtable(get(url_serach_name % entry.name), ['Name', 'Description'])
    out = []
    lenCVE = len(entry_cves)
    i = 0
    for cve in entry_cves:
        if(lenCVE > 5):
            print('%-20s %d/%-25d.' % (entry.name, i, lenCVE), end='\r')
            i += 1
        c = get_cve(cve['Name'])        
        if(not c):
            print('problem', cve['Name'])
        #TODO remove ** REJECTED **
        #TODO no android in version
        #TODO no win process remove version from name
        if(c and hasVersions(c['vulnerable_product'], entry.name, entry.version)):
            out.append(c)
    return out

starsRoll = ['|', '/', '-', '\\']
starsArrLen = len(starsRoll)
def porgressBar(lenBar, cur, max):
    stars = (lenBar*cur)//max
    bar = f'[{"*"*stars}{starsRoll[cur%starsArrLen]}{" "*(lenBar-1-stars)}]'
    return f'{cur}/{max} {bar}'

def look_entries_single_thread(lst_entries):
    print('search entries')
    out = []
    for i in range(0, len(lst_entries)):
        print(porgressBar(20, i, len(lst_entries)), f'<{lst_entries[i].name}>               ', end='\r')
        tmp = look_entry(lst_entries[i])
        if(tmp and len(tmp)>0):
            out.append({'name':lst_entries[i].name, 'version':lst_entries[i].version, 'arr':tmp})
    return out

def look_entries(lst_entries):
    p = Pool(8)
    scrapped_entries = p.map(look_entry, lst_entries)
    out = []
    for i in range(0, len(lst_entries)):
        tmp = scrapped_entries[i]
        if(tmp and len(tmp)>0):
            out.append({'name':lst_entries[i].name, 'version':lst_entries[i].version, 'arr':tmp})
    return out

def printTable(lst):
    #print(lst)
    print(f'{len(lst)} CVES detected')
    for entry_cves in lst:
        name = entry_cves['name']
        version = entry_cves['version']
        print(f'\'{name}\'--{version}')
        for cve in entry_cves['arr']:
            for field in cve_fields_print:
                print(field, ':', cve[field])
            print('--------')

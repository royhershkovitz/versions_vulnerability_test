from utils.HTTP_TOOL import get
import lxml.html as lh
import json
from multiprocessing import Pool
import time
import functools
from utils.cveVersionProcess import hasVersions, summaryHasText

url_search_name = 'https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=%s'
url_search_cve = 'https://cve.circl.lu/api/cve/%s'
close_xml = '>'
open_table = '<table'
close_table = '</table'
def get_just_table(text, fields):
    start = 0
    end = len(text)
    while start < end:
        i = text.find(open_table,start,end)#Start
        if i == -1:
            break
        tmp_start = text.find(close_xml, i,end)
        tmp_end = text.find(close_table, i, end)
        if tmp_end == -1:
            break
        tmp_end = text.find(close_xml, tmp_end, end)
        #print(tmp_start, tmp_end, text[tmp_end-5:tmp_end+5])
        all = True
        for field in fields:
            if all and text.find(field,tmp_start,tmp_end) == -1:
                all = False
                break
        if all:
            return text[tmp_start:tmp_end+1]
        start = tmp_end
    print('table parsing failed')
    exit(-1)

def harvestHTMLtable(text, fields):
    text = get_just_table(text, fields)
    #print(text[:1000])
    doc  = lh.fromstring(text)
    tr_elements = doc.xpath('//tr')
    out = []
    for i in range(1, len(tr_elements)):
        x = {}
        j = 0
        for field in fields:
            x[field] = tr_elements[i][j].text_content().strip()
            j += 1
        out.append(x)
    return out

cve_fields       = ['Published', 'access', 'impact', 'assigner', 'id', 'vulnerable_product', 'summary']
cve_fields_print = [ 'id', 'Vulnerable_version', 'summary', 'assigner', 'Published', 'access', 'impact']
cve_fields_short_print = [ 'id', 'Vulnerable_version', 'summary']
#"access": { "authentication": "NONE",  "complexity": "LOW", "vector": "NETWORK" }
#"impact": { "availability": "PARTIAL", "confidentiality": "NONE", "integrity": "NONE" }
def get_cve(cve_name):
    text = get(url_search_cve % cve_name)
    while text.find('<title>429 Too Many Requests</title') != -1:
        #print(f'--timeout-- ', end='\r')
        time.sleep(1.5)
        text = get(url_search_cve % cve_name)
    try:
        c = json.loads(text)
    except:
        x = min(100,len(text))
        print('Decode problem, text:  <%s>.\n\n' % text[:x])
        return None    
    return c

#get cves and verify version
def look_entry(entry, TOP):
    if not entry.name:#broken parse entries
        return
    entry_cves = harvestHTMLtable(get(url_search_name % entry.name), ['Name', 'Description'])
    if TOP > 0:
        entry_cves = entry_cves[:TOP]
    out = []
    lenCVE = len(entry_cves)
    #print(entry.name, lenCVE)
    i = 0
    for cve in entry_cves:
        if(lenCVE > 5):
            print('%-20s %d/%-25d.' % (entry.name, i, lenCVE), end='\r')
            i += 1
        c = get_cve(cve['Name'])        
        if(not c):
            print('problem <%s>.\n' % cve['Name'])
        elif not c['summary'].startswith('** REJECTED **'):
            v = hasVersions(c['summary'], c['vulnerable_product'], entry.name, entry.version)
            if (v != None):
                c['Vulnerable_version'] = v
                out.append(c)
    return out

#get faster- based just on cve mitre data
def look_entry_fast(entry, TOP):
    if not entry.name:#broken parse entries
        return
    entry_cves = harvestHTMLtable(get(url_search_name % entry.name), ['Name', 'Description'])
    if TOP > 0:
        entry_cves = entry_cves[:TOP]
    
    out = []
    for cve in entry_cves:
        if not cve['Description'].startswith('** REJECTED **'):
            v = summaryHasText(cve['Description'], entry.name, entry.version)
            if v:
                c = {'id':cve['Name'], 'summary':cve['Description'], 'Vulnerable_version': v}
                out.append(c)
    return out

starsRoll = ['|', '/', '-', '\\']
starsArrLen = len(starsRoll)
def progressBar(lenBar, cur, max):
    stars = (lenBar*cur)//max
    bar = f'[{"*"*stars}{starsRoll[cur%starsArrLen]}{" "*(lenBar-1-stars)}]'
    return f'{cur}/{max} {bar}'

def look_entries(lst_entries, fast=False, TOP=50):
    p = Pool(8)
    if fast:
        scrapped_entries = p.map(functools.partial(look_entry_fast, TOP=TOP), lst_entries)
        #scrapped_entries = []
        #for a in lst_entries:
        #    scrapped_entries.append(functools.partial(look_entry_fast, TOP=TOP)(a))
    else:
        scrapped_entries = p.map(functools.partial(look_entry, TOP=TOP), lst_entries)
    out = []
    for i in range(0, len(lst_entries)):
        tmp = scrapped_entries[i]
        if(tmp and len(tmp)>0):
            out.append({'name':lst_entries[i].name, 'version':lst_entries[i].version, 'arr':tmp})
    print("________________________________________________________________________")
    p.close()
    return out

def printTable(lst, PIP=False, Short=False):
    #print(lst)
    print(f'{len(lst)} packages with CVES detected')
    for entry_cves in lst:
        name = entry_cves['name']
        version = entry_cves['version']
        print('\n')
        arrlen = len(entry_cves['arr'])
        print(f'\'{name}\' - \'{version}\' CVEs {arrlen}')
        if PIP:
            print(f'pip project details- https://pypi.org/project/{name}/')
        fields = cve_fields_print
        if Short:
            fields = cve_fields_short_print
        for cve in entry_cves['arr']:
            for field in fields:
                print(field, ':', cve[field])
            print('---------')
        print('*********')

from utils.HTTP_TOOL import get
import lxml.html as lh
import json
from multiprocessing import Pool
import time

url_serach_name = 'https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=%s'
url_serach_cve = 'https://cve.circl.lu/api/cve/%s'
table = 'table'
thead = 'thead'
open_xml = '<'
close_xml = '>'
def get_just_table(text, fields):
    start = 0
    end = len(text)
    while start < end:
        i = text.find(table,start,end)
        tmp_end = text.find(table, i+len(table), end)
        tmp_end = text.find(close_xml, tmp_end, end)
        tmp_start = text.rfind(open_xml,start,i)  
        all = True
        for field in fields:
            if all and text.find(field,tmp_start,tmp_end) == -1:
                all = False
        if all:
            return text[tmp_start:tmp_end+1]
        start = tmp_end
    return ''

#see all relevant HTML objects
def exploreHTML(text):
    doc  = lh.fromstring(text)
    tr_elements = doc.xpath('//tr')
    #print(tr_elements)
    j = 0
    for t in tr_elements:
        i=0
        for t2 in t:
            name=t2.text_content()
            print('%d %d:"%s"'%(j,i,name))
            i+=1
        j+=1

def harvestHTMLtable(text, fields):
    text = get_just_table(text, fields)
    #print(text)
    #exploreHTML(text)
    doc  = lh.fromstring(text)
    tr_elements = doc.xpath('//tr')
    out = []
    for i in range(1, len(tr_elements)):
        x = {}
        j = 0
        for field in fields:
            x[field] = tr_elements[i][j].text_content().strip()
            j += 1
        out.append(x)
    return out

cve_fields       = ['Published', 'access', 'impact', 'assigner', 'id', 'vulnerable_product', 'summary']
cve_fields_print = [ 'id', 'Vulnerable_version', 'summary', 'assigner', 'Published', 'access', 'impact']
#"access": { "authentication": "NONE",  "complexity": "LOW", "vector": "NETWORK" }
#"impact": { "availability": "PARTIAL", "confidentiality": "NONE", "integrity": "NONE" }
def get_cve(cve_name):
    text = get(url_serach_cve % cve_name)
    while text.find('<title>429 Too Many Requests</title') != -1:
        #print(f'--timeout-- ', end='\r')
        time.sleep(1.5)
        text = get(url_serach_cve % cve_name)
    try:
        c = json.loads(text)
    except:
        x = min(100,len(text))
        print('decode problem, text: <', text[:x], '>\n')
        return None    
    return c

def validateNameGetVersionSplit(verArr, name):
    #split name
    #google:chrome:73.0.3683.103
    nameArr = name.split(' ')
    if len(nameArr) <= 1:
        nameArr = name.split('.')#microsoft store naming
    if len(nameArr) <= 1:#no splitting for you
        return -1
    
    i = j = 0
    while i < len(verArr) and verArr[i]!=nameArr[j]:#search for our full name
        i += 1
    while i < len(verArr) and j < len(nameArr) and verArr[i]==nameArr[j]:#for name appears twice
        i += 1
        j += 1
    
    #next sould be version! and we finish name array
    if i + 1 > len(verArr) or j < len(nameArr):
        return validateNameExist(verArr, '_'.join(nameArr))
    return i - 1#the last name index

#return what the name index
def validateNameExist(verArr, name):
    i = 0
    #double name
    while i < len(verArr) and verArr[i]!=name:#search for our full name
        i += 1
    if i + 1 < len(verArr) and verArr[i+1]==name:#for name appears twice
        i += 1

    if i + 1 > len(verArr):#next sould be version!
        return -1
    return i

def validateNameGetVersion(verArr, name):
    # no android in version
    for a in verArr:
        if a == 'android':
            return -1
    
    i = validateNameExist(verArr, name)
    
    if i == -1:
        return validateNameGetVersionSplit(verArr, name)    
    return i

#>>> 'ba' > 'aa'
#True
#>>> 'ba' > 'bb'
#False
#>>> '11' > '2'
#False        
#compare 0.6.45-1ubuntu1 vs 0.6.55
#0.6.4 vs 0.6.15
from packaging.version import LegacyVersion
def compareVersions(version1, version2):
    return LegacyVersion(version1) <= LegacyVersion(version2)
    
def equalVersions(version1, version2):
    return LegacyVersion(version1) == LegacyVersion(version2)

def isVersion(ver):
    return len(ver.split('.')) > 1

def hasVersion(verText, name, cur_vr):
    name = name.lower()
    verText = verText.lower()
    verArr = verText.split(':')
    #does the name in the vulnerable products?
    i = validateNameGetVersion(verArr, name)
    if i == -1:
        return False
    
    if not cur_vr: #if we don't know the version we better return true
        return True
    
    if isVersion(verArr[i+1]):
        return compareVersions(cur_vr, verArr[i+1])
    #else:
    #    return verArr[i+1]=='*'#not stable enough since some have versions in the description
    return False

#before 1.15.2 and 2.0.1
#through 7.70
#return validating Text
ver_words = ['before', 'through']
def hasText(summary, name, cur_vr):
    if not name in summary:
        return None
    summary = summary.split(' ')
    for i in range(1, len(summary)):
        if isVersion(summary[i]):
            compver = summary[i].strip()
            if(compver.endswith(',') or compver.endswith('.') or compver.endswith('-') or compver.endswith(':')):
                compver = compver[:-1]#fix version from text
            for bef_word in ver_words:
                if bef_word == summary[i-1] and compareVersions(cur_vr, compver):
                    return f'{summary[i-1]} {summary[i]}'
            if equalVersions(cur_vr, compver):
                return compver
    return None

#validate that at least one version text place has my full name
def verTextHasName(versions, name):    
    name = name.lower()
    if not versions:
        return True#no version mean no way to validate but summary
    for verText in versions:
        verText = verText.lower()
        verArr = verText.split(':')
        #does the name in the vulnerable products?
        i = validateNameGetVersion(verArr, name)
        if i != -1:
            return True
    return False

#getting from up to down (increase version num) make it easier to match the right verTex
def hasVersions(summary, versions, name, cur_vr):
    # man deb-version
    # [epoch:]upstream_version[-debian_revision]
    # : is the current epoch, used for downgrading 2:1.31.2
    # remove epoch for comparison
    # we do not need it and it is actually not comparing well with it (since one have it and the other don't)
    i = cur_vr.find(':')
    if i != -1:
        cur_vr = cur_vr[i+1:]
    for verText in versions:
        if hasVersion(verText, name, cur_vr):
            return verText
    if verTextHasName(versions, name):
        return hasText(summary, name, cur_vr)
    return None

#get cves and verify version
def look_entry(entry):
    entry_cves = harvestHTMLtable(get(url_serach_name % entry.name), ['Name', 'Description'])
    out = []
    lenCVE = len(entry_cves)
    i = 0
    for cve in entry_cves:
        if(lenCVE > 5):
            print('%-20s %d/%-25d.' % (entry.name, i, lenCVE), end='\r')
            i += 1
        c = get_cve(cve['Name'])        
        if(not c):
            print('problem <%-20s>.\n' % cve['Name'])
        elif not c['summary'].startswith('** REJECTED **'):
            v = hasVersions(c['summary'], c['vulnerable_product'], entry.name, entry.version)
            if (v != None):
                c['Vulnerable_version'] = v
                out.append(c)
    return out

starsRoll = ['|', '/', '-', '\\']
starsArrLen = len(starsRoll)
def porgressBar(lenBar, cur, max):
    stars = (lenBar*cur)//max
    bar = f'[{"*"*stars}{starsRoll[cur%starsArrLen]}{" "*(lenBar-1-stars)}]'
    return f'{cur}/{max} {bar}'

def look_entries_single_thread(lst_entries):
    print('search entries')
    out = []
    for i in range(0, len(lst_entries)):
        print(porgressBar(20, i, len(lst_entries)), f'<{lst_entries[i].name}>               ', end='\r')
        tmp = look_entry(lst_entries[i])
        if(tmp and len(tmp)>0):
            out.append({'name':lst_entries[i].name, 'version':lst_entries[i].version, 'arr':tmp})
    print("________________________________________________________________________")
    return out

def look_entries(lst_entries):
    p = Pool(8)
    scrapped_entries = p.map(look_entry, lst_entries)
    out = []
    for i in range(0, len(lst_entries)):
        tmp = scrapped_entries[i]
        if(tmp and len(tmp)>0):
            out.append({'name':lst_entries[i].name, 'version':lst_entries[i].version, 'arr':tmp})
    print("________________________________________________________________________")
    return out

def printTable(lst):
    #print(lst)
    print(f'{len(lst)} packages with CVES detected')
    for entry_cves in lst:
        name = entry_cves['name']
        version = entry_cves['version']
        print('\n')
        arrlen = len(entry_cves['arr'])
        print(f'\'{name}\' - \'{version}\' CVEs {arrlen}')
        for cve in entry_cves['arr']:
            for field in cve_fields_print:
                print(field, ':', cve[field])
            print('---------')
        print('*********')

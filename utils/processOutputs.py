from multiprocessing import Pool
from utils.command import Command
from os import listdir
from os.path import isdir

class Entry(object):
	def __init__(self, name, version):
		self.name = name.strip()
		self.version = version.strip()
        
	def __repr__(self):
		return 'name:*%s* vr:*%s*' % (self.name, self.version)

class PIPEntry(Entry):
  def __init__(self, toParse):
    toParse = toParse.split('==')
    name = toParse[0]
    version = toParse[1]
    Entry.__init__(self, name, version)

def processPIP(lst):
    p = Pool(5)
    out = p.map(PIPEntry, lst)
    p.close()
    return out

def findXOccurance(string, i, c, x):
  if x==0:
    return i
  found = False
  while i < len(string):
    if string[i]==c:
      if not found:
        x-=1
        found = True
        if x==0:
          return i
    else:
      found = False
    i+=1
  return -1

spam_text = ['version', '(x64)', '(64-bit)', 'en-US', 'en-us', '(amd64)', '(32-bit x86)', '(x86)', '(x86_64)', '-']
#list of table heads and content
class ParserWIN(object):
  def __init__(self, lst):    
    dashes = lst[1]
    #print(lst[:3])
    #print(dashes)
    self.versionIndex    = findXOccurance(dashes, 0, '-', 2)
    self.versionIndexEnd = findXOccurance(dashes, self.versionIndex, '-', 2)
    #print(self.versionIndex)
    p = Pool(5)
    self.out = p.map(self.winentry, lst[2:])
    p.close()

  def isVersion(self, ver):
    return len(ver.split('.')) > 1
  
  def winentry(self, Str):
    name    = Str[:self.versionIndex].strip()
    version = Str[self.versionIndex:self.versionIndexEnd].strip()
    #remove version from name
    clean_name = []
    for a in name.split(' '):
      if not self.isVersion(a):
        clean_name.append(a)
    name = ' '.join(clean_name)
  
    name = name.replace('.', ' ')#windows store format
    name = name.replace('_', ' ')#some names
    
    #remove spam text
    for txt in spam_text:
      name = name.replace(txt, '')
      name = name.replace(' )', ')')
      name = name.replace('( ', '(')
      name = name.replace('  ', ' ')
    return Entry(name, version)
  
def equals(e1, e2):
  return e1.name == e2.name and e1.version == e2.version

def processWindows(lst):
  pw = ParserWIN(lst)
  j = 0
  #win process remove doubles and remove version from name
  if not pw.out[0].name:
      pw.out.pop(0)
      j += 1
  for i in range(1, len(pw.out)):
    if not pw.out[i-j].name or equals(pw.out[i-j], pw.out[i-j - 1]):
      pw.out.pop(i-j)
      j += 1
  return pw.out

class LinuxEntry(Entry):
  def __init__(self, toParse):
    toParse = toParse.split()
    name = toParse[1]
    version = toParse[2]
    Entry.__init__(self, name, version)

def processLinux(lst):
    p = Pool(5)
    out = p.map(LinuxEntry, lst)
    p.close()
    return out

class DarwinEntry(Entry):
  def __init__(self, appname):
    #map names -> to os request
    # example
    # defaults read /Applications/Steam.app/Contents/Info.plist CFBundleVersion 
    # if CFBundleShortVersionString not working try
    # CFBundleVersion
    terminal = ['zsh', '-c', f'defaults read \'/Applications/{appname}/Contents/Info.plist\' CFBundleShortVersionString']
    command = Command(terminal, '.', silence=True)
    version = command.run(timeout=100)[0]
    if not version:
      terminal = ['zsh', '-c', f'defaults read \'/Applications/{appname}/Contents/Info.plist\' CFBundleVersion']
      command = Command(terminal, '.', silence=True)
      version = command.run(timeout=100)[0]
    #print(version)
    #remove .app from name
    name = appname[:-4]#'delete .app'
    Entry.__init__(self, name, version)

def processDarwin(lst):
    p = Pool(5)
    out = p.map(DarwinEntry, lst)
    p.close()
    return out

class BrewEntry(Entry):
  def __init__(self, toParse):
    toParse = toParse.split(' ')
    name = toParse[0]
    version = toParse[1]
    Entry.__init__(self, name, version)

def processBrew(lst):
    p = Pool(5)
    out = p.map(BrewEntry, lst)
    p.close()
    return out

def harvestWindows():
    cmd1 = ["powershell.exe", "Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | Format-Table -AutoSize | Out-String -Width 10000"]
    cmd2 = ["powershell.exe", "Get-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | Format-Table -AutoSize | Out-String -Width 10000"]
    cmd3 = ["powershell.exe", "Get-AppxPackage | Select-Object Name, Version, Architecture, Publisher | Format-Table -AutoSize | Out-String -Width 10000"]
    command1 = Command(cmd1, '.')
    output = command1.run(timeout=100)
    output = processWindows(output)
    command2 = Command(cmd2, '.')
    tmp = command2.run(timeout=100)
    output.extend(processWindows(tmp))
    command3 = Command(cmd3, '.')
    tmp = command3.run(timeout=100)
    output.extend(processWindows(tmp))
    return output

def harvestLinux():
    cmd = ["sh", "-c", "dpkg -l"]
    command = Command(cmd, '.')
    output = command.run(timeout=100)
    output = output[5:]#cut dpkg explains and table head
    return processLinux(output)

app_path_macos = '/Applications'
def harvestDarwin():
    #scan /Applications
    applications = [f for f in listdir(app_path_macos) if f.endswith('.app')]
    subdirs = [f for f in listdir(app_path_macos) if isdir(f'{app_path_macos}/{f}') and not f.endswith('.app')]

    # scan sub directories
    for subdir in subdirs:
      applications.extend([f'{subdir}/{f}' for f in listdir(f'{app_path_macos}/{subdir}') if f.endswith('.app')])

    out_ver = processDarwin(applications)

    #add more versions -> 
    #brew list --versions
    #brew cask list --versions
    terminal = ['zsh', '-c', "brew list --versions"]
    terminal2 = ['zsh', '-c', "brew cask list --versions"]
    command1 = Command(terminal, '.')
    command2 = Command(terminal2, '.')
    output = command1.run(timeout=100)
    output.extend(command2.run(timeout=100))
    out_ver.extend(processBrew(output))
    return out_ver

